#summary Describes basic principles of Dirigent project behaviour and architecture.

NOT FINISHED YET

= Contents =

    * Introduction
    * Basic principles
    * Dirigent project: package description
    * Sequence diagrams
          * Basic course
          * Metafacade creation
          * Metafacade creation - decorator


= Introduction =

/ TODO translate 

Dirigent je projekt, jehož cílem je umožnit transformaci modelů software z různých zdrojů do výstupních souborů (skriptů, zdrojových kódů). Obecně by měl umožňovat načtení modelu aplikace z různých zdrojů (soubory či databázové repozitáře vytvořené různými modelovacími) a transformaci vybraného objektu modelu, části modelu či celého modelu do nějakého výstupu (souboru, případně může být například vygenerován a spuštěn nějaký kód atd.). Podobu výstupu definují XML šablony, další nastavení se nastavují v konfiguračním souboru.

Tento dokument se zabývá principy fungování těch částí aplikací, které se dotýkají řešeného úkolu, případně které bude nutné upravovat. Generování výstupu ze šablon, stejně jako ostatní práce se šablonami a práce s konfiguračním souborem aplikace nejsou předmětem analýzy. Pro splnění zadání stačí předpokládat správnou funkčnost těchto součástí aplikace, pro řešení jejich konkrétní implementace není příliš podstatná.
Základní principy
Projekt Dirigent obsahuje GUI využívající technologii Flex, které ovšem v době zahájení prací na projektu nebylo dostupné a není ani open source. V rámci projektu bude proto během vývoje ke spouštění využíván pouze ant skript, který zajistí postupné provedení všech požadovaných úkonů (vygenerování tabulek, vygenerování transformačních skriptů, jejich spuštění,...). Tento skript se nachází v adresáři dirigent-demo/oracle/build.xml a má následující cíle (targets):

TODO translate /

    * L0.install: runs SQL scripts which trunctate and recreate L0 layer of the database (source data layer).
    * L0.load: loads data to the L0 layer.
    * L2.generate: calls the main method of Dirigent and passes the following URI to it:  {479A188C-C78E-47c3-8829-2B418E9F5989}. This is the URI of model package "L2 - Datamart Layer". First, Dirigent generates the transformed data for this element. There is no pattern for this element type, however, as it is an IComposite element, its children elements (which are dimensions and fact table) are transformed into the output data. So, the result are drop and create scripts for dimensions and fact table.
    * L2.install: executes all drop scripts and than executes all create scripts created by L2.generate
    * L2.load: SCD mapping itself. Generates and also executes scripts for ELT processes.

The program operation starts with an org.dirigent.Dirigent.main(String[]) method call, which expects the first parameter to be an URI of the model object to be transformed into the output data.

Dirigent - diagram komponent

Vstupem programu jsou:

    * model (aktuálně jsou podporovány repozitář s modelem Enterprise Architect v databázi a CSV soubory), který obsahuje údaje, na jejichž základě vzniknou konkrétní výstupní souboru
    * XML šablony pro transformaci do výstupních souborů, které určují podobu výstupních soubourů a definují, kde se v nich použijí údaje z modelu
    * URI objektu v modelu, který se bude transformovat. Podle typu objektu se použijí příslušné šablony a vytvoří odpovídající výstupní soubor.
    * konfigurační soubor (obsahuje například informace o typu modelu)



Pro objekt modelu s daným URI je nejprve vytvořena metafasáda, tj. dojde k transformaci objektu (objektů) modelu ze specifického formátu ve vstupních datech do jednotné objektové reprezentace. Podle typu objektu je vybrána šablona, pomocí které jsou z metafasády vytvořena výstupní data. Tato data mohou být uložena do souboru, případně spuštěna nad nějakou databází (v případě SQL skriptu) atd. (konkrétní vykonaná operace s výstupními daty - uložení, spuštění - závisí na aktuálním nastavení).

Program lze rozdělit do těchto komponent (viz diagram):

    * Generator - obsahuje hlavní běh programu, řídí volání metod ostatních komponent
    * MetafacadeBuilder - podle typu modelu vrací odpovídající Decorator
    * Decorator - vytváří metafasádu na základě dat z VO objektů
    * PatternBuilder - na základě šablon a objektů metafasády generuje výstup
    * Executor - různé typy Executorů provádějí různé operace s výstupem PatternBuilderu (uložení do souboru, spuštění atp.)
    * DirigentConfig - ostatním vrstvám zprostředkovává nastavení z konfiguračního souboru


Popis balíčků projektu Dirigent
Dirigent se nyní skládá ze čtyř projektů:

    * dirigent - základní projekt obsahující jádro aplikace (načítání modelů a tvorba metafasády, načítání šablon a transformace modelu), schopný po zkompilování fungovat jako konzolová aplikace.
    * dirigent-demo - projekt vyhrazený pro část aplikace zabývající se datovými sklady (která bude demonstrovat možnosti celého projektu Dirigent). Tvorba tohoto projektu je předmětem zadání
    * dirigent-blazeds - projekt s GUI využívající technologie BlazeDS. Tato část není opensource a pro tvorbu zadané části projektu není k dispozici a nebude využívána.
    * dirigent-test - obsahuje jednotkové testy projektu dirigent



Následuje popis balíčků projektu dirigent.
org.dirigent
Obsahuje jedinou třídu Dirigent.java s jedinou metodou main, která se volá při spuštění programu a ve svém těle obsahuje pouze zavolání metody Generator.generate, jíž předá první argument příkazové řádky (s předpokladem, že jde o URI objektu, z něhož má být vygenerován výstup).
org.dirigent.config
Zajišťuje přístup ke konfiguračnímu souboru a datům v něm (jako jsou údaje o typu a URL modelu, případně přístupovým údajům k němu apod.). Balík není předmětem analýzy.
org.dirigent.executor
Třídy starající se o vykonání patřičné operace s výstupními daty. V současné době existují dva executory: FileExecutor, ukládající data do souboru a JDBCStatementExecutor, spouštějící data jako SQL skript nad zvolenou databází (oba jsou potomky třídy IPatternExecutor). Dále je zde třída ExecutorFactory, jejíž metoda getExecutor(String)vrací příslušný Executor podle typu (zadaného ve formě řetězce - ten lze získat pro každý objekt IPatternStep z jeho metody getType(); to se ovšem již týká balíku org.dirigent.pattern).
org.dirigent.generator
Obsahuje třídu Generator, která generuje výstupní soubory podle šablon
org.dirigent.metafacade
Obsahuje třídy spojené s metafasádou. Kořen tohoto balíku obsahuje interfaces definující rozhraní jednotlivých tříd metafasády (např. IMapping, IDimension, ITable) atd. Co do dědičnosti jsou tato rozhraní uspořádána v poměrně složité hierarchické struktuře - viz diagram.

Balík org.dirigent.metafacade - class diagram (část 1)

Balík org.dirigent.metafacade - class diagram (část 2)
org.dirigent.metafacade.builder
Obsahuje abstraktní třídu MetafacadeBuilder s abstraktními metodami představujícími rozhraní pro jednotlivé metafacadebuildery (jejichž implementace je závislá na formátu modelu). Dále tato třída obsahuje statickou metodu getMetafacadeBuilder, která podle nastavení typu modelu (property dirigent.model.type třídy DirigentConfig) vrátí konkrétní metafacadebuilder.
Důležitou (ale v obecném MetafacadeBuilder neimplementovanou) metodou je getMetafacade(String), která vrací objekt metafasády (IElement) pro objekt s daným URI (string v parametru). Třída ovšem obsahuje i další metody.
org.dirigent.metafacade.builder.csv
Třídy pro generování metafasády z modelu ve formátu CSV. Balík není předmětem analýzy.
org.dirigent.metafacade.builder.decorator
Obsahuje obecné Decoratory - třídy implementující rozhraní z balíku org.dirigent.metafacade, která informace o modelu získávají z VO objektů z balíku org.dirigent.metafacade.builder.vo. Jedná se například o AttributeDecorator (implementující IAttribute s datovým zdrojem AttributeVO), DimensionDecorator a mnoho dalších.
org.dirigent.metafacade.builder.vo
Obsahuje obecné/jednotné VO metafasády - AttributeVO, BIColumnVO atd. Datový model, který zpřístupňují, je nezávislý na původním formátu modelu.
org.dirigent.metafacade.builder.ea
Obsahuje třídu EAHelper, která se stará o připojení k databázi s EA repozitářem, a dále třídu EAMetafacadeBuilder, která je potomkem abstraktní třídy MetafacadeBuilder. Její asi nejpodstatnější metoda, getMetafacade(String), vrací instanci EA***Decorator, podle typu objektu, jehož metafasáda se má vygenerovat.
org.dirigent.metafacade.builder.ea.dao, org.dirigent.metafacade.builder.ea.vo
DAO a DTO (VO) objekty pro EA model.
org.dirigent.metafacade.builder.ea.decorator
Decoratory pro EA model (obdobné org.dirigent.metafacade.builder.decorator, ovšem využívající VO objekty z balíku org.dirigent.metafacade.builder.ea.vo, které přistupují přímo k datům EA modelu).
org.dirigent.pattern
Balík řešící generování výstupu z XML šablon. Balík není předmětem analýzy.
org.dirigent.pdi.job.dirigent
Zajišťuje integraci projektu do Pentahoo Data Integration. Balík není předmětem analýzy.

Ukázky běhu programu
Základní průběh

Program po spuštění zavolá statickou metodu Generator.generate(String), které v argumentu předá prvním parametr příkazové řádk. Argumentem přetížené metody generate je buď řetězec s URI transformovaného objektu nebo instance IGenerable, což je objekt metafasády.
Meetoda generate(String), jejímž argumentem je řetězec s URI, pouze zajistí vygenerování metafasády pro daný objekt a poté zavolá metodu generate, které je metafasáda (IGenerable) pro daný objekt předána v argumentu.
Metoda generate(IGenerable) podle typu IGenerable vybere příslušnou šablonu (IPattern), podle které zajistí vygenerování výstupu (generování výstupu není v diagramu obsaženo).


Následující sekvenční diagramy obsahují příklad běhu programu při dirigování metafasády pro objekt typu Dimension. V modelu EA jde o objekt typu Class se stereotypem BiDimension.

Poznámka: je tedy patrné, že jednomu typu objektů v původním modelu může odpovídat více objektů metafasády a naopak (rozhodnutí, na který objekt metafasády transformovat původní objekt, se pak může učinit podle dalších vlastností původního objektu - zde například podle stereotypu).

Vytváření metafasády

Je zavolána statická metoda MetafacadeBuilder.getMetafacadeBuilder(). Ta vrací implementaci abstraktní třídy MetafacadeBuilder, která odpovídá použitému typu modelu (který je definovaný v konfiguračním souboru). V tomto případě předpokládáme model Enterprise Architect, dojde proto k vytvoření nové instance třídy EAMetafacadeBuilder. Tento objekt se již postará o vygenerování odpovídající metafasády.
Zavoláme metodu getMetafacade(String), jejímž parametrem bude URI objektu “typu” Dimension. Přes EAElementDAO bude získána instance v:EAElementVO pro příslušný objekt modelu (metodou EAElementDAO.getEAElement(String), kde v parametru je URI objektu). Přes tento VO objekt lze přistupovat k vlastnostem objektu daného URI v modelu.
Podle vlastností v (v tomto případě v.type a v.stereotype) se vybere typ objektu metafasády, který se má generovat, a je vytvořen příslušný dekorátor - v tomto případě tedy  EADimensionDecorator. Více v dalším diagramu.

Vytváření metafasády - decorator
V diagramu jsou zobrazeny volání metod a konstruktorů předků z metod a konstruktorů potomků během vytváření metafasády pro objekt Dimension. Je zde vědomě poněkud pozměněn význam jednotlivých prvků UML diagramu: pokud bude objekt :A volat nějakou metodu objektu super:B, znamená to, že volá metodu třídy B, která je předkem třídy A (objekt :A a objekt super:B jsou tedy vlastně tentýž objekt). Je-li jako první akce po vytvoření objektu :A vytvořen objekt super:B, znamená to volání konstruktoru předka v konstruktoru objektu :A.


(Pokračování z minulého diagramu.) Objekt EADimensionDecorator implementuje rozhraní IDimension a sám tedy představuje výsledný objekt metafasády pro vybraný objekt-dimenzi původního modelu. V parametru konstruktoru je objektu předán EAElementVO objekt pro příslušný objekt modelu (jde tedy o objekt v:EAElementVO z předchozího modelu). Dojde postupně k volání konstruktorů předků.
V konstruktoru EATableDecorator (přímý předek EADimensionDecorator) dojde k vytvoření objektu TableVO, což je VO objekt metafasády (již tedy ne EA modelu). Je volána metoda EATableDecorator.init(EAElementVO, TableVO), která volá metodu EAElementDecorator.init(EAElementVO, ElementVO). Ta podle dat získaných z EAElementVO, tedy prvního parametru (v diagramu pseudometoda EAElementVO.getProperties()) naplní daty objekt v druhém parametru - ElementVO (pseudometoda ElementVO.setProperties()). Zde tedy dochází k samotnému vytváření metafasády:

public static ElementVO init(EAElementVO ea,ElementVO v) {        
       v.uri=ea.guid;
       v.id=ea.objectId;
       v.name=ea.name;
       v.type=ea.type;
       v.description=ea.note;
       v.stereotype=ea.stereotype;
       v.packageId=ea.packageId;
       v.properties=new
         EAObjectPropertyDAO().getObjectProperties(ea.objectId);
       v.parentUri=ea.parentGuid;
       v.alias = ea.alias;
       v.keywords = ea.keywords;
       return v;
   }

Například URI objektu je v EA modelu uloženo v proměnné guid, v objektu metafasády je v proměnné uri. Atd.

Vytvořený TableVO (obecně ElementVO) je dále předáván konstruktorům dalších předků (zde TableDecorator a ElementDecorator), ty si většinou uloží odkaz na něj - a to kvůli překrývaným metodám. Rozhraní metafasády IDimension je totiž potomkem ITable a to potomkem IElement.

Dojde-li tedy například k zavolání metody getName() (metoda IElement, lze ji tedy zavolat i nad objektem EADimensionDecorator, který implementuje rozhraní IDimension), je obsloužena metodou ElementDecorator.getName(). ElementDecorator si drží odkaz na vygenerovaný TableVO a vrátí tak hodnotu vlastnosti name tohoto objektu.
Přímo v EADimensionDecorator jsou pak implementovány metody týkající se pouze dimenzí, tedy například getSCDType().

Existují také metody, jejichž návratovou hodnotou jsou další objekty metafasády. Například IElement.getParent(), která vrací objekt IElement s metafasádou rodiče aktuálního elementu. V takovém případě dojde k volání generování vygenerování potřebných objektů přímo v těle této metody:

   @Override
   public IElement getParent() {
       if ( ! element.parentUri.equals("") ) {
             return MetafacadeBuilder
                  .getMetafacadeBuilder()
                  .getMetafacade(element.parentUri);
       } else {
           l.warning("element " + element.name + " (" + element.uri + ") don't have any parent!");
           return null;
       }
   }

Pokud tedy na vygenerovaném objektu metafasády tuto metodu zavoláme, dojde k vytvoření metafasády pro rodičovský element (existuje-li), tj. k proběhnutí celého (obdobného) procesu popsaného tímto a předchozím sekvenčním diagramem.
Podobně jsou také generovány například atributy objektů metafasády (metoda getAttributes() vracející kolekci IAttribute). S tím rozdílem, že IElement si odkaz na kolekci drží, ovšem k inicializaci kolekce a vygenerování metafasády atributů dojde až ve chvíli, kdy je metoda getAttributes() zavolána (lazy loading).